#!/bin/bash

originalLDFlagsCache=originalLDFLAGS.txt

clean() {
    local target=${1}
    local what=${2}

    local bc=${target}.0.6.coverage.bc
    local o=${target}.coverage.o
    local exe=${target}.coverage
    rm -f ${bc} ${o} ${exe} *.blocks.map

    if [[ "${what}" == "coverage" ]]; then
        return
    fi

    rm -f ${target}.*
    make clean

    if [[ "${what}" == "all" ]]; then
        rm -f ${originalLDFlagsCache}
    fi
}

fuzz() {

    if [[ $# == 0 ]]; then
        echo "usage: ${0} <target executable>"
        return 1
    fi
    local target=${1}
    local clean=${2}
    if [[ "${clean}" == "-clean" ]]; then
        clean ${target} ${3}
        return
    fi

    # exit when any command fails
    set -e

    # keep track of the last executed command
    local currentCommand=
    trap 'local lastCommand=${currentCommand}; local currentCommand=${BASH_COMMAND}' DEBUG
    # echo an error message before exiting
    trap 'echo "\"${lastCommand}\" command filed with exit code $?."' EXIT

    # save env
    local oldCC=${CC}
    local oldCXX=${CXX}
    local oldRANLIB=${RANLIB}
    local oldCFLAGS=${CFLAGS}
    local oldLDFLAGS=${LDFLAGS}

    local flto="-flto -fuse-ld=lld" # flto makes .o files .bc files
    local myLDFLAGS="${flto} -Wl,-plugin-opt=save-temps" # generates .bc files also

    export CC=clang
    export CXX=clang++
    export RANLIB=llvm-ranlib
    export CFLAGS=" -flto ${oldCFLAGS} "
    export LDFLAGS=" ${myLDFLAGS} ${oldLDFLAGS} "

    if [[ -f "${originalLDFlagsCache}" ]]; then
        true
    else
        # only run configure once
        ./configure
        rm -f a.out.* # generated by autotools for testing
        # need these for final link
        make -n | tail -n 1 | sed 's/.*'"${myLDFLAGS}"'//' > "${originalLDFlagsCache}"
    fi
    local originalLDFLAGS=$(cat "${originalLDFlagsCache}")

    make -j$(getconf _NPROCESSORS_ONLN)

    local projectDir=~/workspace/sync/SmartNeuralFuzzer
    local libDir=${projectDir}/build/lib
    local register=${libDir}/libpass.register.so
    local loadPasses="-load=${libDir}/libpass.coverage.block.so -load=${libDir}/libpass.coverage.branch.so"
    local runtimes="${libDir}/libruntime.coverage.block.a ${libDir}/libruntime.coverage.branch.a"
    local bc=${target}.0.6.coverage.bc
    local o=${target}.coverage.o
    local exe=${target}.coverage

    # optimize (instrument), compile bc to obj, and then link everything
    LD_PRELOAD=${register} opt-9 -O3 ${loadPasses} ${target}.0.5.precodegen.bc > ${bc}
    clang ${bc} -c -o ${o}
    clang ${flto} ${o} ${runtimes} -lstdc++ -lstdc++fs ${originalLDFLAGS} -o ${exe}

    # restore original env
    export CC=${oldCC}
    export CXX=${oldCXX}
    export RANLIB=${oldRANLIB}
    export CFLAGS=${oldCFLAGS}
    export LDFLAGS=${oldLDFLAGS}

}

fuzz "$@"
